---
layout: post
title: 'Tutorial: Timers and PWM (and a cheeky AM radio transmission) using STM32CubeIDE'
subtitle: 
gh-repo: kiwih/cubeide-timers-demo
gh-badge: [star, fork, follow]
share-img: 
tags: [tutorial, stm32, STM32CubeIDE, embedded, c]
---

Measuring, monitoring, and reacting to the passage of time in embedded systems is an ubiquitous requirement.
For instance, you might decide that you want to toggle an output every millisecond.
You might be tasked to implement a system that samples an ADC once a second.
You might want to change your `main()`'s `while(1)` to feature a delay such that it becomes a loop with a fixed period.

In order to achieve this, you must become proficient with one of the most useful peripherals you'll ever encounter within your microcontrollers: Timers.
These are embedded counters which measure the passage of time as a function of counting microcontroller clock ticks (you can actually get them to count other things as well, for instance pulses on an external pin).

Setting up timers, however, can be a little tricky - especially in microcontrollers as capable as the STM32F series. 
So, in this, my third tutorial using STM32CubeIDE, I'm going to walk through a quick explanation of how we can get started with some of the most common use cases, and I'll finish with a (very silly) demo application where we (ab)use a timer to produce an AM radio signal.

I'll be assuming that you already know the basics of creating a project, navigating inside CubeIDE, and setting up debugging and so on.
If not, then please [check out this earlier tutorial, in which I walk through getting started with STM32CubeIDE](https://01001000.xyz/2020-05-11-Tutorial-STM32CubeIDE-Getting-started/).

So what are we waiting for? Let's get started!

TL;DR: Timers. The complete code project is available [here](https://github.com/kiwih/cubeide-timers-demo).

# Equipment for this tutorial

Today I will be using the following:

* (Free) Ubuntu Linux 20.04 because developing on Linux makes me happy and Ubuntu makes it easy. Don't worry if you're on Windows, you should be able to follow along with roughly the same steps. 
* (Free) STM32CubeIDE
* ($27.26 from [Amazon Prime](https://amzn.to/2BDK6ID), $15.05 from [Amazon](https://amzn.to/3gEp6AA)) The `Nucleo-F303RE` development board.
* ($6 from [Amazon Prime](https://amzn.to/33GRwXe)) Easy-to-use ribbon cables (there's more than you need here - to be honest, you'll need only one, but they're handy to have around).

_Note: The above Amazon links are affiliate links. As always I encourage you to shop around, but Amazon usually has pretty good pricing._

# Setting up the Project

1. Open STM32CubeIDE.
2. Start a new project for the `Nucleo-F303RE` dev board (or w/e you're using) called something sensible e.g. _cubeide-timers-demo_.
3. Answer 'Yes' to _Initialize all peripherals in their default configuration?_.
4. Answer 'Yes' to _Open device configuration view?_. 

The Device Configuration View is where you configure exactly which pins/peripherals are enabled and what their settings are.
For now we'll leave it at its defaults, but let's quickly note the hardware available to us:

![Default Config]({{ 'assets/img/cubeide-timers/default-hardware.png' | relative_url }}){: .mx-auto.d-block :}

As you can see there is a push button (called B1) at pin PC13, an LED called LD2 at pin PA5, and a UART TX/RX at PA2/PA3 which connects to the programmer's virtual COM port (if you're unsure about this, do [check out my earlier tutorial](https://01001000.xyz/2020-05-11-Tutorial-STM32CubeIDE-Getting-started/) where I discuss it in some detail).

For now, this is all we will need. So, let us head over to the code window. 
Navigate using the project explorer on the left to `main.c`.

# The Basics: Blink an LED using HAL_Delay() 

Before we start playing with the timer peripherals themselves, we're going to get an idea of Initially we're simply going to make that LED blink to get an idea of how the timer can be made to be useful.

Inside `main.c`, head to the `while(1)` inside `main()`. 
As a reminder, for these autogenerated files, you _must_ only introduce code in the marked areas.
If you put code outside the _USER CODE_ sections it will be deleted whenever the code generator runs (which is whenever we make a change to the hardware configuration).

For now, we're going to add some code, as below. Remember you can get autocomplete suggestions by pressing Ctrl+Space at any time.

![Autosuggest]({{ 'assets/img/cubeide-timers/eclipse-autosuggest.png' | relative_url }}){: .mx-auto.d-block :}

First, let us add some code to create a custom `my_printf` function.
This will be helpful as it will let us send messages to the virtual COM port.

*In `main.c`, in the includes section:*
```c
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdbool.h>
#include <stdio.h>
#include <stdarg.h> //needed for the custom printf declaration to support varying numbers of arguments
/* USER CODE END Includes */
```

*In `main.c`, in the private user code section:*
```c
/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void uart2_printf(const char *fmt, ...) {
  char buffer[256];
  va_list args;
  va_start(args, fmt);
  vsnprintf(buffer, sizeof(buffer), fmt, args);
  va_end(args);

  HAL_UART_Transmit(&huart2, buffer, strlen(buffer), -1);
}
/* USER CODE END 0 */
```

Add the following code:

*In `main.c`, `main()`:*
```c
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
	  uart2_printf("Hello!\r\n");
	  HAL_Delay(1000);
  }
  /* USER CODE END 3 */
```

What does this do? Hopefully you're able to work it out! In the infinite loop, it will first toggle the LED pin (changing it from high to low or vice versa), then it will send out "Hello!" on the UART, and finally it will run the `HAL_Delay()` function.
`HAL_Delay` is what is known as a _blocking_ function. 
Inside the function is a loop which will iterate until the number of milliseconds that you specified as the argument elapses.
In other words, it will pause execution. In our case, we asked it to pause for 1000 milliseconds.
As such, when we compile and download this function to the board, the LED will blink.

<video width='100%' controls>
  <source src="{{ '/assets/vid/cubeide-intro/blink.mp4' | relative_url }}" type="video/mp4">
Your browser does not support the video tag.
</video>

# The Basics: Our own custom delay function

One of the features of the `HAL_Delay` function is that it is based upon the _SysTick_ of your STM32 microcontroller. 
By default, this is an interrupt which triggers every one millisecond.
That doesn't give us a tremendous amount of _resolution_ (for instance, if we wanted to have a delay of 500 microseconds, that's not possible by default).

Now, we know that the microcontroller architecture provides us a wealth of _timer peripherals_ for us to use.
Let's see if we can use one of these to make our own delay function which has a higher resolution than the default `HAL_Delay()`.
According to the [ST General Purpose Timer Cookbook for STM32 Microcontrollers](https://www.st.com/resource/en/application_note/dm00236305-generalpurpose-timer-cookbook-for-stm32-microcontrollers-stmicroelectronics.pdf) (an excellent resource which you can take a look at for further information), the first timer, TIM1, has an internal block diagram that looks like this:

![TIM1 block]({{ 'assets/img/cubeide-timers/timer-block-diagram.png' | relative_url }}){: .mx-auto.d-block :}

There's quite a lot going on here! Fortunately, we want to just use one of the most simple modes.
Let's examine what we want to do: Firstly, we want to count time, not input events, so from the blue box we'll be having the timer source based upon the clock ticks of the microcontroller. 
Secondly, we will need to decide how _quickly_ we count based on that clock source, i.e. should we count the clock ticks directly, or should we divide them by some value? This decision is represented by the _prescaler_ value (depicted by the _PSC prescaler_ block in the green Time-base box). Finally, the actual "count" of the timer is stored in the register CNT, before further decision-making hardware uses this value in other ways (we'll get to these later).

Let's walk through an example. Let us decide that we wish to have TIM1 count in _microseconds_. Now we need to know how fast the TIM1 input clock is. In the Device Configuration Tool, we can see what this is under the _Clock Configuration_ panel:

![Clock config]({{ 'assets/img/cubeide-timers/clock-config.png' | relative_url }}){: .mx-auto.d-block :}

Aha! Now, while the two speeds are the same for APB1 timer clocks and APB2 timer clocks, if they _were_ different, how would we know which source TIM1 depended upon?

The [STM32F303RE datasheet](https://www.st.com/resource/en/datasheet/stm32f303re.pdf) can rescue us here:

![CPU timer block]({{ 'assets/img/cubeide-timers/cpu-timer-block.png' | relative_url }}){: .mx-auto.d-block :}

So TIM1 actually comes from APB2 timer clock source.

Now that we know that in our configuration TIM1 has a 72MHz source, we can start setting up the device.
If we want a 1 microsecond resolution, we know that we'll need to divide the clock by 72, as 72 MHz / 72 = 1 MHz, and 1 / 1 MHz = 1 microsecond.
There's one other note you must remember, which is that the prescaler is always stored as 1 less than the division.
That is, a prescaler of 0 would divide the clock by 1 (i.e. it would not divide it).
For our desired division, 72, we must therefore set the prescaler as 71.

Head back into the device configuration tool, and expand the settings for _TIM1_.
Set the Clock Source to _Internal Clock_, and the Prescaler to 71, as depicted.

![CPU timer block]({{ 'assets/img/cubeide-timers/tim1-config.png' | relative_url }}){: .mx-auto.d-block :}

Now, save your configuration and press yes to regenerate code when prompted.

You should notice that an extra line of configuration has appeared in your `main.c`:

*In `main.c`, `main():*
```c
/* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_TIM1_Init();
```

Great! 
Let's now add our own little custom function:

*In `main.c` private user code section:*
```c
/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void uart2_printf(const char *fmt, ...) { . . . }

void delay_us (uint16_t us) //warning: this function is not reentrant
{
	__HAL_TIM_SET_COUNTER(&htim1,0); //reset the timer counter
    HAL_TIM_Base_Start(&htim1); //start the timer
	while (__HAL_TIM_GET_COUNTER(&htim1) < us);  // wait for the counter to reach the us value provided as an argument
    HAL_TIM_Base_Stop(&htim1); //stop the timer.
}
/* USER CODE END 0 */
```

Let's walk through this piece of code.
We take in as an argument `us` the amount of time to wait in microseconds. Note that our argument is a 16-bit type. This is because TIM1's register CNT is only 16 bits wide. That means it can only count up to 2^16-1, or 65535.

The first line of the function body resets the counter at the core of TIM1 by setting the CNT register (see the block diagram) to zero. 
The second line then starts the timer.
The third line waits until the CNT register is greater than the argument we provided.
This works because we know that CNT register will advance by 1 every 1 microsecond.
Finally, the fourth line stops the timer.

There's one thing to note with this function's implementation: it is not _reentrant_. What does this mean?
Because the function has _side effects_ (it resets/starts/stops the timer) when it is called, if this function was to be used _in parallel_ the two function calls would interfere with one another. It is possible to write a version of this function such that it is reentrant (like `HAL_Delay()`), but let's keep it simple and not worry about that for now.

Let's try out our new functionality by modifying our `while(1)` in `main.c`:

*In `main.c`, `main()`:*
```c



# A timer interrupt


There are some drawbacks to using the `HAL_Delay` function.
Like all blocking functions, it prevents us from multi-tasking.

* Replace delay() with interrupts to blink LED using Timer2
* Add more interrupts to show we're doing it in parallel (using breadboard?)

| SD Adapter side | `Nucleo-F303RE` side |
| :-------------- | :------------------- |
| CS              | PB1 (GPIO SD_CS)     |
| SCK             | PB13 (SPI2 SCLK)     |
| MOSI            | PB15 (SPI2 MOSI)     |
| MISO            | PB14 (SPI2 MISO)     |
| VCC             | 5V                   |
| GND             | GND                  |

* Configure Timer3 to have a UART output every 1s. 

# Segue: A watchdog interrupt

* Reboot

# Generating PWM:

* Delete Timer2/3 interrupt/code.

* The basics, talk about theory of PWM

* Blink LED using Timer2 PWM.

# Putting it together: Let's make an AM radio transmission

* AM radio format + carrier waves etc

Adding a pin:

Since we want to be emitting a radio signal, we're going to need some kind of antenna.
We'll make this very easy: We'll use a single wire connected to one of the microcontroller's pins that has PWM capability. 

So, let's quickly see what our pin options are. 

On the `Nucleo-F303-RE` we have both Arduino style headers as well as ST's branded _morpho_ headers, which are the double rows of pins down each side. 
For now, I'm going to use the pin that is labelled PWM/D9 on the silk screen.

[This document](https://www.st.com/resource/en/user_manual/dm00105823-stm32-nucleo-64-boards-mb1136-stmicroelectronics.pdf) from ST provides us with the correct pinout for the F303-RE, or alternatively (and in a more attractive and detailed way) the same info is presented on ST's mbed OS website [here](https://os.mbed.com/platforms/ST-Nucleo-F303RE/).

(Update after here) Straight away I can see that SPI2 is the winner - it is broken out onto the pins in the bottom right, along with PB1 which we will use for the chip select line.

![SPI2 Pins]({{ 'assets/img/cubeide-sd-card/nucleo_f303re_morpho_spi2.png' | relative_url }}){: .mx-auto.d-block :}

So, let's set up our SPI2 and GPIO in the Device Configuration View. Click SPI2 on the left, and then set it to Full Duplex Master with no Hardware NSS.
Then set the Data Size to 8 bits, and the clock prescaler to 128 (SD cards start up with low speeds and switch to higher speeds later. We'll look at how to do this soon).

![SPI2 Config]({{ 'assets/img/cubeide-sd-card/cubeide-spi2-setup.png' | relative_url }}){: .mx-auto.d-block :}

Then, create your Chip Select line on PB1 - I find setting a sensible name is also good:

![SD_CS Config]({{ 'assets/img/cubeide-sd-card/cubeide-sd-cs-setup.png' | relative_url }}){: .mx-auto.d-block :}

Finally, as we're going to be using the SD card with the FAT file system, scroll down in the device categories to `Middleware`, and expand this, then enable `FATFS` as `User-defined`. You may leave all other parameters as their defaults.

![FATFS Config]({{ 'assets/img/cubeide-sd-card/cubeide-fatfs-setup.png' | relative_url }}){: .mx-auto.d-block :}

Now save your Device Configuration, and when it asks, 'Yes' to _Do you want to generate Code?_ and 'Yes' to _Do you want to open [the C/C++] perspective now?_.

* Musical notes

* PWM to make note (square wave) over carrier wave 

* Listening using radio or SDR



*In `user_diskio.c` Decl:*
```c
/* USER CODE BEGIN DECL */

/* Includes ------------------------------------------------------------------*/
#include <string.h>
#include "ff_gen_drv.h"
#include "user_diskio_spi.h"
```

# Conclusions

If you would like the complete code that accompanies this blog post, it is made available in the associated Github repository [here](https://github.com/kiwih/cubeide-twinkle).